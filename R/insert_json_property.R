#' Insert a Property into Elements of a Nested JSON Array
#'
#' @description
#' This function enables the insertion of a new property at a specific position
#' within elements in nested arrays of a JSON structure. This is particularly useful for
#' modifying complex nested JSON structures with fine-grained control.
#'
#' @details
#' The function traverses a JSON structure following a specified path to reach nested arrays.
#' For each matching element, it inserts a property at the specified position. The property value
#' can be either a static value or dynamically generated by a function that receives contextual
#' information about each element.
#' 
#' This function is useful for:
#' \itemize{
#'   \item Adding metadata to nested array elements
#'   \item Reorganizing properties within elements
#'   \item Batch modifications to complex nested JSON structures
#'   \item Establishing relationships between parent and child elements
#' }
#'
#' @param json_data A JSON object (as an R list)
#' @param array_path Path to the array as a vector (e.g., c("items", "Test") for items[*].Test[*])
#' @param property_name Name of the property to insert
#' @param property_value Value of the property or a function that is called for each element.
#'        If it's a function, it receives the following parameters: elem, index, parent, parent_index, root
#' @param position_type Type of positioning: "after", "before", "position", "first", "last"
#' @param position_ref Reference property or position (depending on position_type)
#' @param filter_fn Optional function to filter which elements to modify
#' @param verbose Whether status messages should be displayed
#'
#' @return The modified JSON data structure
#' @export
#'
#' @examples
#' # Example JSON as a string
#' json_str <- '{
#'   "items": [
#'     {
#'       "id": 1,
#'       "name": "Laptop",
#'       "Test": [
#'         {
#'           "DisplayName": "Test 1",
#'           "Level": 1
#'         },
#'         {
#'           "DisplayName": "Test 2",
#'           "Level": 2
#'         }
#'       ]
#'     }
#'   ]
#' }'
#' 
#' # Convert to R list
#' json_data <- jsonlite::fromJSON(json_str, simplifyVector = FALSE)
#' 
#' # Insert "TestId" with value 1 after "DisplayName"
#' result <- insert_json_property(
#'   json_data,
#'   array_path = c("items", "Test"),
#'   property_name = "TestId",
#'   property_value = 1,
#'   position_type = "after",
#'   position_ref = "DisplayName"
#' )
#' 
#' # Insert "ItemName" with the name of the parent item
#' result2 <- insert_json_property(
#'   json_data,
#'   array_path = c("items", "Test"),
#'   property_name = "ItemName",
#'   property_value = function(elem, index, parent, parent_index, root) {
#'     return(parent$name)  # Access the name of the parent item
#'   },
#'   position_type = "first"
#' )
insert_json_property <- function(
    json_data,                # JSON data (as R list)
    array_path,               # Path to array as vector (e.g., c("items", "Test"))
    property_name,            # Name of the property to insert
    property_value,           # Value or function for the value
    position_type = "after",  # "after", "before", "position", "first", "last"
    position_ref = NULL,      # Reference property or position
    filter_fn = NULL,         # Optional filter function
    verbose = FALSE           # Debug output
) {
  # Validate inputs
  if (!is.list(json_data)) {
    stop("json_data must be a list")
  }
  
  if (!is.character(array_path) || length(array_path) == 0) {
    stop("array_path must be a non-empty character vector")
  }
  
  if (!is.character(property_name) || length(property_name) != 1) {
    stop("property_name must be a single character string")
  }
  
  if (!position_type %in% c("after", "before", "position", "first", "last")) {
    stop("position_type must be one of the following values: 'after', 'before', 'position', 'first', 'last'")
  }
  
  if (position_type %in% c("after", "before") && !is.null(position_ref) && !is.character(position_ref)) {
    stop("position_ref must be a character string when position_type is 'after' or 'before'")
  }
  
  if (position_type %in% c("after", "before") && is.null(position_ref)) {
    stop("position_ref must be a character string when position_type is 'after' or 'before'")
  }
  
  if (position_type == "position" && (is.null(position_ref) || !is.numeric(position_ref))) {
    stop("position_ref must be a number when position_type is 'position'")
  }
  
  if (!is.null(filter_fn) && !is.function(filter_fn)) {
    stop("filter_fn must be a function or NULL")
  }
  
  # Helper function to recursively traverse the JSON structure
  process_node <- function(node, path_index = 1, parent_elements = list(), parent_indices = list()) {
    # Base case: If we've reached the end of the path
    if (path_index > length(array_path)) {
      return(node)
    }
    
    current_key <- array_path[path_index]
    
    # If the current node contains the array we're looking for
    if (current_key %in% names(node)) {
      # If we're at the last array in the path, process the elements
      if (path_index == length(array_path)) {
        
        if (verbose) {
          cat(sprintf("Processing array '%s'...\n", current_key))
        }
        
        # Is it an array?
        if (is.list(node[[current_key]])) {
          # Counter for modified elements
          modified_count <- 0
          
          # For each element in the current array
          for (i in 1:length(node[[current_key]])) {
            current_element <- node[[current_key]][[i]]
            
            # Check if the element should be filtered
            should_process <- is.null(filter_fn) || filter_fn(current_element)
            
            if (should_process) {
              # Calculate the property value (if it's a function)
              actual_property_value <- if (is.function(property_value)) {
                # Determine the root element (if available)
                root_element <- if (length(parent_elements) > 0) parent_elements[[1]] else NULL
                
                # Determine the direct parent element (if available)
                parent_element <- if (length(parent_elements) > 0) parent_elements[[length(parent_elements)]] else NULL
                parent_index <- if (length(parent_indices) > 0) parent_indices[[length(parent_indices)]] else NULL
                
                # Call the function with appropriate parameters
                tryCatch({
                  property_value(
                    elem = current_element, 
                    index = i, 
                    parent = parent_element, 
                    parent_index = parent_index, 
                    root = root_element
                  )
                }, error = function(e) {
                  # Fallback to simpler call if the function doesn't accept all parameters
                  tryCatch({
                    property_value(
                      elem = current_element, 
                      index = i
                    )
                  }, error = function(e2) {
                    # As a last resort, try with all available parameters
                    property_value(
                      elem = current_element, 
                      index = i, 
                      parent = parent_element, 
                      parent_index = parent_index, 
                      root = root_element,
                      parent_elements = parent_elements,
                      parent_indices = parent_indices
                    )
                  })
                })
              } else {
                property_value
              }
              
              # Create a new object with the reordered properties
              new_element <- list()
              
              # Different positioning types
              if (position_type == "first") {
                # Add new property first
                new_element[[property_name]] <- actual_property_value
                # Then all other properties
                for (prop in names(current_element)) {
                  new_element[[prop]] <- current_element[[prop]]
                }
              } 
              else if (position_type == "last") {
                # Add all existing properties first
                for (prop in names(current_element)) {
                  new_element[[prop]] <- current_element[[prop]]
                }
                # Then the new property at the end
                new_element[[property_name]] <- actual_property_value
              }
              else if (position_type == "position" && !is.null(position_ref) && is.numeric(position_ref)) {
                # Add the properties in the right order
                props <- names(current_element)
                pos <- min(max(1, position_ref), length(props) + 1)
                
                for (j in 1:length(props)) {
                  if (j == pos) {
                    new_element[[property_name]] <- actual_property_value
                  }
                  new_element[[props[j]]] <- current_element[[props[j]]]
                }
                
                # If the position is at the end
                if (pos > length(props)) {
                  new_element[[property_name]] <- actual_property_value
                }
              }
              else if ((position_type == "after" || position_type == "before") && !is.null(position_ref)) {
                # Add properties before or after a specific reference property
                found_ref <- FALSE
                
                for (prop in names(current_element)) {
                  if (position_type == "before" && prop == position_ref) {
                    # Add new property before the reference
                    new_element[[property_name]] <- actual_property_value
                    found_ref <- TRUE
                  }
                  
                  # Add the current property
                  new_element[[prop]] <- current_element[[prop]]
                  
                  if (position_type == "after" && prop == position_ref) {
                    # Add new property after the reference
                    new_element[[property_name]] <- actual_property_value
                    found_ref <- TRUE
                  }
                }
                
                # If the reference property wasn't found
                if (!found_ref && verbose) {
                  cat(sprintf("Warning: Reference property '%s' not found in element %d\n", 
                              position_ref, i))
                }
              }
              else {
                # Default case: add at the end
                for (prop in names(current_element)) {
                  new_element[[prop]] <- current_element[[prop]]
                }
                new_element[[property_name]] <- actual_property_value
              }
              
              # Replace the element
              node[[current_key]][[i]] <- new_element
              modified_count <- modified_count + 1
              
              if (verbose) {
                cat(sprintf("Element %d updated\n", i))
              }
            }
          }
          
          if (verbose) {
            cat(sprintf("%d elements in array '%s' modified\n", modified_count, current_key))
          }
        } else if (verbose) {
          cat(sprintf("'%s' is not an array or is empty\n", current_key))
        }
      }
      # If we have more arrays in the path, recurse for each element in the current array
      else {
        # Is it an array?
        if (is.list(node[[current_key]])) {
          for (i in 1:length(node[[current_key]])) {
            # Update the path of parent elements
            new_parent_elements <- c(parent_elements, list(node[[current_key]][[i]]))
            new_parent_indices <- c(parent_indices, i)
            
            # Recursive call with updated parent elements
            node[[current_key]][[i]] <- process_node(
              node[[current_key]][[i]], 
              path_index + 1,
              new_parent_elements,
              new_parent_indices
            )
          }
        } else if (verbose) {
          cat(sprintf("'%s' is not an array or is empty\n", current_key))
        }
      }
    } else if (verbose) {
      cat(sprintf("Key '%s' not found\n", current_key))
    }
    
    return(node)
  }
  
  # Start the processing
  if (verbose) {
    cat("Starting processing...\n")
  }
  
  # Apply the processing recursively
  result <- process_node(json_data)
  
  if (verbose) {
    cat("Processing completed\n")
  }
  
  return(result)
}